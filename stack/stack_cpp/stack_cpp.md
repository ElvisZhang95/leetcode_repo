## Stack in Cpp

### 堆栈Stack

堆栈是一个后进先出(Last In First Out)表，即 LIFO 表

C++ STL 的堆栈泛化是直接通过现有的序列容器来实现的，默认使用双端队列deque的数据结构，当然，可以采用其他线性结构（vector 或 list等），只要提供堆栈的入栈、出栈、栈顶元素访问和判断是否为空的操作即可。

stack的元素出栈操作是不返回栈顶元素的，需要另外通过取栈顶函数获得。这种分离实现是考虑到出栈函数若直接返回栈顶元素，将会导致返回值的数据引用安全问题或不必要的低效复制函数的调用。

从 stack 内部实现看，stack 堆栈是不设最大容量的，但可通过 size 函数获取当前堆栈的大小，以判断是否允许继续让元素入栈，实现具有最大容量限制的堆栈。

stack堆栈容器的C++标准头文件为 stack ，必须用宏语句 "#include <stack>" 包含进来，才可对 stack 堆栈的程序进行编译。

- stack<int> s; 创建一个空的stack对象

  stack(const stack&)
  复制构造函数，用一个 stack 堆栈创建一个新的堆栈。
  例如，下面的代码利用 s1 ，创建一个以双向链表为底层容器的空堆栈对象 s2 。
  // stack<int, list<int> >   s1;
  stack<int, list<int> >   s2(s1);

- empty() 堆栈为空则返回真

- pop() 移除栈顶元素
- push() 在栈顶增加元素
- size() 返回栈中元素数目
- top() 返回栈顶元素



### 单调栈

1. 单调栈分为单调递增栈和单调递减栈
   1. 单调递增栈即栈内元素保持单调递增的栈
   2. 同理单调递减栈即栈内元素保持单调递减的栈

2. 操作规则（下面都以单调递增栈为例）

   1. 如果新的元素比栈顶元素大，就入栈
   2. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小

3. 加入这样一个规则之后，会有什么效果

   1. 栈内的元素是递增的
   2. 当一个栈内元素被弹出来时，说明新元素是第一个比该元素小的元素

   3. 因为栈内元素是递增的，所以出栈的元素前面第一个比该元素小的就是新的栈顶

4. 代码

  ```c++
  stack<int> st;
  for(int i = 0; i < nums.size(); i++)
  {
  while(!st.empty() && st.top() > nums[i])
  {
  	st.pop();
  }
  st.push(nums[i]);
  }
  ```

5. 画图理解

![](./resource/7e876ae756613053b3432cebc9274e9dbdaafd2e6b8492d37fc34ee98f7655ea-图片.png)
